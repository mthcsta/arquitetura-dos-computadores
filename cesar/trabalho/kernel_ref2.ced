;
;
;******************************************************************************
;
;	Arquivo de Referência para iniciar o desenvolvimento do kernel
;
;	versão: 2020.1
;
;	Áreas de memória
;
;	8000 - FF7F		_KRN_INT
;					Área de Kernel para implementação dos alunos
;
;	FF80 - FFBF 	_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;******************************************************************************

_APP:		equ	h0100
_KRN_INT:	equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;------------------------------------------------------------------------------
;	Área reservada para os periféricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
	org	_IOAREA16
	daw	[31]
IVET:	dw	0			; Vetor de interrupção

; Acesso em 8 bits
	org	_IOAREA08
	dab	[23]
TIMDT:	db	0			; Registro de programação do timer
INTS:	db	0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db	0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db	0			; Status do teclado
TECDT:	db	0			; Dado do teclado
VISOR:	dab	[36]		; Portas de acesso ao visor

CR:			equ	H0D
BS:			equ	H08


		
	
;
;------------------------------------------------------------------------------
;	Area para o kernel
;	Inicialização (reset)
;	Funções para usa do aplicação
;------------------------------------------------------------------------------
		org		_KRN_INT
		dw		_reset
		dw		_kbhit
		dw		_shift
		dw		_ctrl
		dw		_getchar
		dw		_putchar
		dw		_putmsg
		dw		_start
		dw		_ready
	

	
;------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;------------------------------------------------------------------------------
_reset:
; 1) Desabilitar o sistema de interrupções
; 2) Inicializar o stack pointer (SP = R6)
		mov	#HFF7F	r6
; 3) Inicializar as variáveis internas usadas pelo sistema de interrupções (IVET, INTE, etc.)
		mov	#_ISR	IVET
; 4) Inicializar as variáveis internas do kernel
; 5) Inicializar o teclado zerando o byte de estado (TECST, endereço 65498)
; 6) Inicializar o timer
		mov	#10	TIMDT
; 7) Limpar o visor
		mov 	#VISOR 	r0
; 8) Habilitar interrupções
; 9) Retornar para o programa de aplicação com um desvio para o endereço H0100 da memória
		jmp		_APP


;------------------------------------------------------------------------------
;	BOOL kbhit(VOID)
;
;	Retorna em R0 o estado do teclado. Cada bit de R0 representa uma informação:
;	•	Bit 0: indica se há tecla;
;	•	Bit 1: indica se o estado SHIFT está ligado;
;	•	Bit 2: indica se o estado CTRL está ligado.
;	•	Os outros bits devem retornar, sempre, em zero.
;	Essa função não é bloqueante. Ou seja, deve retornar imediatamente para o chamador, com a informação do teclado.
;------------------------------------------------------------------------------
_kbhit: 
	mov	#0	R0
	cmp	TECST	#h80
	bne	semTecla
	add	#1	R0
	semTecla:
		cmp	SHIFT	#1
		bne	semShift
		add	#2	R0
	semShift:
		cmp	CTRL	#1
		bne	fim
		add	#4	R0		

	fim:	
		rts		r7

	
;------------------------------------------------------------------------------
;	VOID shift(BOOL)
;
;Funçao:
;	Liga ou desliga o estado SHIFT, conforme o valor de R0: 
;	•     Zero: desliga o estado SHIFT 
;	•     Outro valor: liga o estado SHIFT 
;------------------------------------------------------------------------------
_shift:
	tst R0
	bne desliga_shift
	mov	#1	SHIFT
	rts	r7
	desliga_shift:
		mov	#0	SHIFT
		rts		r7



;------------------------------------------------------------------------------
;	VOID ctrl(BOOL)
;
;Funçao:
;	Liga ou desliga o estado CTRL, conforme o valor de R0: 
;	•     Zero: desliga o estado CTRL 
;	•     Outro valor: liga o estado CTRL 
;------------------------------------------------------------------------------
_ctrl:
	tst R0
	bne desliga_ctrl
	mov	#1	CTRL
	rts	r7
	desliga_ctrl:
		mov 	#0	CTRL
		rts		r7

	
;------------------------------------------------------------------------------
;	CHAR getchar(VOID)
;
;Funçao:
;	Obtém o código ASCII de um caractere digitado no teclado e devolve o mesmo no registrador R0.
;	Não “ecoa” o caractere lido no visor.
;	Diferentemente da “_kbhit”, permanece bloqueada, aguardando que algum caractere seja digitado.
;	Retorna as letras conforme o estado SHIFT e CTRL:
;	•	Se ambos desligados, retorna sempre letras minúsculas (H61 – H7A);
;	•	Se CTRL ligado, converte letras em caracteres de controle correspondentes (valores ASCII entre H00 e H1A)
;	•	Se CTRL desligado e SHIFT ligado, converte letras para as correspondentes letras maiúsculas (valores ASCII entre H41 e H5A)
;------------------------------------------------------------------------------
_getchar:
	getchar_While:
		cmp	TECST,#H80 	
		bne	getchar_While
			
		mov	TECDT,R0
			
		clr	TECST
	
	rts		r7


;------------------------------------------------------------------------------
;	VOID	putchar(WORD, WORD, CHAR)
;
;Funçao:
;	Escreve um caractere no visor. Os parâmetros de entrada da função são os seguintes: 
;	• R0: ASCII do caractere a ser colocado no visor (entre H00 e H7E) 
;	• R1: Número do visor a ser usado (0 ou 1) 
;	• R2: Posição no visor selecionado (entre 0 e 17) 
;	Se a função for executada corretamente, retornar 0 (zero) em R0. 
;	Caso ocorra erro ou se os valores fornecidos na entrada sejam inválidos, a função deve ser ignorada e retornado valor diferente de 0 (zero) em R0. 
;------------------------------------------------------------------------------
_putchar:
	tst r1
	beq	notAdd			; if (visor == 0)
	add	#17	r1		; ir ao visor 1.
	notAdd:
		add	r2	r1
		mov 	r0 	VISOR(r1)
	rts	r7

	
;------------------------------------------------------------------------------
;	VOID	putmsg(WORD, WORD, CHAR*)
;
;Funçao:
;	Escreve uma mensagem no visor. Os parâmetros de entrada da função são os seguintes:
;	• R0: Endereço do string a ser colocado no visor. O string deve ser terminado com “\0” (string “C”). 
;	• R1: Número do visor a ser usado (0 ou 1) 
;	• R2: Posição no visor selecionado (entre 0 e 17) 
;	Se a função for executada corretamente, retornar 0 (zero) em R0. 
;	Caso ocorra erro ou se os valores fornecidos na entrada sejam inválidos, a função deve ser ignorada e retornado valor diferente de 0 (zero) em R0. 
;	Caso o string seja maior do que o tamanho do visor (18 caracteres), o string deve ser truncado. 
;------------------------------------------------------------------------------
_putmsg:
	dec r0
	tst r1
	beq	loop_putmsg		; if (visor == 0)
	add	#17	r1		; ir ao visor 1.
	
	loop_putmsg:
		mov	(r0) VISOR(r1)
		inc	r1
		inc	r0
		and	#H00FF	(r0)
		bne	loop_putmsg

	rts		r7

	
;------------------------------------------------------------------------------
;	VOID start (WORD)
;
;Funçao:
;	Inicializa uma temporização
;	Se for chamada, novamente, antes do tempo atingir o seu final, um novo tempo será programado.
;	Essa função deve ser usada em conjunto com a função _ready
;	Esse timer deve ter uma resolução de 10ms
;Entra:
;	R0 = valor do tempo, em milisegundos
;------------------------------------------------------------------------------
_start:
	_n:	dw	0
	mov	r0	TIMDT
	clr	INTS
	clr	r4
	
	
	while_1:
		mov	INTS	r4
		and 	#1 	r4
		beq 	continue
		
		and	#hfe	INTS
		inc	_n
		
		cmp	_n	#10
		blt	continue
		clr	INTS
		clr	_n
		clr	TIMDT
		br	fimm
	
	continue: 
		jmp while_1	
fimm:
		rts		r7
		

;------------------------------------------------------------------------------
;	bool ready(void)
;
;Funçao:
;	Informa se o tempo programado pela função _start esgotou-se.
;Retorna:
;	R0==0, se o tempo programado não se esgotou.
;	R0<>0, se o tempo programado estogou-se
;------------------------------------------------------------------------------
_ready:
;	cmp	#0 r0
;	bne	muda
;	rts	r7
;	muda:
		rts		r7

_isr:
	


SHIFT:	dw 0
CTRL:	dw 0
